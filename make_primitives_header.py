
import re
import sys

# C macros are too klunky to do what we want. 
# So we are going to write a script to generate a header file with the primitives that we want to be included
# This generates two files: a VM-INCLUDE file and a PRIMITIVES file

# Defines a macro for the name plus an underscore

NUM_OPS = 1 # always have NOOP so start at 1
name2args, name2rhs = dict(), dict()

for filename in sys.argv[1:]:
	for line in open(filename):
		if re.match("^\s*#", line) or not re.match(r"[a-zA-Z0-9]",line): continue # skip comments
		line = line.strip() # remove whitespace
		
		name, args, rhs = re.split(r"\t", line)
		#print ">> ", name, args, rhs
		
		# add an underscore if not there
		if not re.search("_$",name): name = name+"_"
		
		assert name not in name2args
		
		name2args[name] = args
		name2rhs[name] = rhs
		
		NUM_OPS += 1
	

# Sorted order (low nargs first since these tend to have higher prior)
names = sorted(name2args.keys(), key=lambda x: name2args[x])

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Print out the virtual machine lines:
vminclude = open("src/__VM_INCLUDE.cu", 'w')
print >>vminclude, "/* GENERATED BY make_primitives_header.py in Makefile. DO NOT EDIT */\n\n";
for n in names:
	print >>vminclude, "\tcase %s: stack[newtop] = %s; break;" % (n, name2rhs[n])
vminclude.close()



# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# print out the header definitions
primitives = open("src/__PRIMITIVES.cu", 'w')
print >>primitives, "/* GENERATED BY make_primitives_header.py in Makefile. DO NOT EDIT */\n\n";
print >>primitives, "const int NUM_OPS=%i;"%NUM_OPS
print >>primitives, "\n\n"
# NOOP here is a special symbol that MUST be 0
print >>primitives, "enum OPS { NOOP_=0,"+",".join([ n+"="+str(i+1) for i,n in enumerate(names)])+"};"
print >>primitives, "\n\n"

# Leave a space ina ll for NOOP
print >>primitives, "__device__ const int NARGS[]  = {0, "+",".join([name2args[n] for n in names])+" };"
print >>primitives, " const int hNARGS[] = {0, "+",".join([name2args[n] for n in names])+" };"
print >>primitives, " const char* NAMES[] = { \"<NA>\", "+",".join(["\""+re.sub("_$","",n if name2args[n]==0 else n.lower())+"\"" for n in names])+" };"


# And things that are used in print, but may or may not be defined
print >>primitives, "\n // Non-defined primitives, used potentially by print_program_as_expression\n"
if "CONSTANT_" not in names: print >>primitives, "#define CONSTANT_ -991" # so that code doesn't crash that uses this
if "ADD_" not in names: print >>primitives, "#define ADD_ -992" # so that code doesn't crash that uses this
if "SUB_" not in names: print >>primitives, "#define SUB_ -993" # so that code doesn't crash that uses this
if "MUL_" not in names: print >>primitives, "#define MUL_ -994" # so that code doesn't crash that uses this
if "DIV_" not in names: print >>primitives, "#define DIV_ -995" # so that code doesn't crash that uses this
if "POW_" not in names: print >>primitives, "#define POW_ -996" # so that code doesn't crash that uses this

primitives.close()





