/*
 * GPUropolis - 2013 Aug 30 - Steve Piantadosi 
 * 
 * Virtual machine for interpreting programs on the device
 */

__device__ data_t f_output(data_t X, hypothesis* h, data_t* stack) {

	int top = 0;
	
	// used if we have constants
	int constant_i = 0; // index into the constant array, increasing order
	
	// We could start at p=0 to avoid branching, but actually here we start at the program length since its faster for short programs
	for(int p=0;p<MAX_PROGRAM_LENGTH;p++) { // program pointer -- IF YOU CHANGE THIS, CHANGE IT IN THE PROGRAM PRINTER TO AVOID CONST WEIRDNESS
		op_t op = h->program[p];
		
		int newtop = top + stack_change(op);
		
		// a few checks
		assert(top >=0 && top < MAX_PROGRAM_LENGTH);
		assert(constant_i >=0 && constant_i < MAX_PROGRAM_LENGTH);
		
		switch(op){
			// Fast ops: http://developer.download.nvidia.com/compute/cuda/4_2/rel/toolkit/docs/online/group__CUDA__MATH__INTRINSIC__SINGLE.html
			case NOOP_: break; // ignore NOOP_
			
			// This is generated by an external python system since C macros weren't quite up to the task
			#include "__VM_INCLUDE.cu"

			default: assert(0); // if anything else...	
		}
		
		//update the top
		top = newtop;
		
		// Hmm this shouldn't be needed, but seems to be?
		if(is_invalid(stack[top])) return CUDART_NAN_F;
	}
	
	return stack[top];
}
